package main

import (
	"log"
)

/**
BM算法:
https://mojotv.cn/algorithm/string-bm
https://blog.csdn.net/qq_21201267/article/details/92799488

1977 年,德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明了一种新的字符串匹配算法：Boyer-Moore 算法,简称 BM 算法.
该算法 从模式串的尾部开始匹配,且拥有在最坏情况下 O(N) 的时间复杂度.
有数据表明,在实践中,比 KMP 算法的实际效能高,可以快大概 3-5 倍.
BM算法的一个特点是当不匹配的时候一次性可以跳过不止一个字符.
即它不需要对被搜索的字符串中的字符进行逐一比较,而会跳过其中某些部分.
通常搜索关键字越长,算法速度越快.
它的效率来自于这样的事实：对于每一次失败的匹配尝试,算法都能够使用这些信息来排除尽可能多的无法匹配的位置.

坏字符规则（bad-character shift）
在 BM 算法中,模式串中的字符跟主串进行匹配的时候是由后向前进行匹配,对于上图来说最先比对的是模式串中的 d 发现和主串中的 c 不相等,那么此时主串中的 c 就叫做坏字符
坏字符:模式串中第一个跟主串不相等的字符（模式串倒序匹配）,叫做坏字符（主串字符） 此时坏字符就是主串中的 c
那么此时模式串该向后移动几位呢,做法是这样的,从模式串中查找坏字符的位置（从后向前找到第一个匹配的就停下来）记作 k 默认值为 -1 表示没有找到,然后将模式串向后移动i - k位 此时通过坏字符 c去模式串 abd 中查找发现没有找到,那么 k = -1,此时移动 2 - (-1) = 3 位

好后缀规则（good-suffix shift）
对于主串和模式串来说存在相等的串就是好后缀(从后向前)
在模式串中寻找(从后向前),是否还有与好后缀一样的字符串,如果有的话将其向后移动到之前好后缀的位置
*/
func main() {
	str := "ababd"
	target := "abd"
	log.Println("BM算法查找:", BM(str, target))

}

func BM(haystack string, needle string) int {

	return -1
}
